using System;
using System.IO;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Xml.Linq;
using Newtonsoft.Json.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Numerics;//libreria utilizada para poder usar el BigInteger
using System.Security.Cryptography; // Importante para el hashing SHA256
using System.Text; // Para usar Encoding
using System.Security.Cryptography.X509Certificates;
//7899026363169
//8001933192886 
//RSA
class Program
{
    /*----------------RUTAS----------------*/
    static string folderPath = @"C:\Users\driva\OneDrive - Universidad Rafael Landivar\Escritorio\LABORATORIO DATOS II\Lab4\Lab4_DiegoRivas_DatosII\Lab_DiegoRivas_DatosII\inputs"; //aqui estan las conv y cartas
    static string outputFolderPath = @"C:\Users\driva\OneDrive - Universidad Rafael Landivar\Escritorio\LABORATORIO DATOS II\Lab4\Lab4_DiegoRivas_DatosII\Lab_DiegoRivas_DatosII\OUTPUT"; // donde se guardaran los archivos
    static string csvFilePath = @"C:\Users\driva\OneDrive - Universidad Rafael Landivar\Escritorio\LABORATORIO DATOS II\Lab4\Lab4_DiegoRivas_DatosII\Lab_DiegoRivas_DatosII\input.csv";  // ruta de tu archivo CSV
    static string signPath = @"C:\Users\driva\OneDrive - Universidad Rafael Landivar\Escritorio\LABORATORIO DATOS II\Lab4\Lab4_DiegoRivas_DatosII\Lab_DiegoRivas_DatosII\LAB_4\FIRMAS\conversation_signature.txt"; //aqui se guarda la FIRMA
    static string SignatureValidationPath = @"C:\Users\driva\OneDrive - Universidad Rafael Landivar\Escritorio\LABORATORIO DATOS II\Lab4\Lab4_DiegoRivas_DatosII\Lab_DiegoRivas_DatosII\LAB_4\SIGNATURE_VALIDATION"; //ruta donde se separan los archivos
    /*-------------------------------------*/
    private static BTree bTree = new BTree(9);  // Asumimos un grado t=9 para el árbol B
    static string key1 = "KEYONE";
    static string key2 = "KEYTWO";
    static int bitLength = 256; //256, 512, 1024, 2048...
    public static string HashValue;//aqui se amlacenara temporalmente el hash en lo que se le aplica la key
    /*-------------------------------------*/
    static void Main()
    {
        Console.WriteLine("Ingresa el DPI para buscar el archivo correspondiente: ");
        string dpiInput = Console.ReadLine();

        // Búsqueda en el archivo CSV
        int OptionMenu;
        do
        {
            Console.WriteLine("-----------------------MENU DE OPCIONES-----------------------");
            Console.WriteLine("1. CODIFICACION Y DECODIFICACION\n" +
                              "2. CIFRADO Y DECIFRADO (CARTAS)\n" +
                              "3. FIRMA\n" +
                              "4. VERIFICACION DE FIRMA\n" +
                              "5. LIMPIAR CONSOLA\n" +
                              "6. SALIR\n");
            OptionMenu = Convert.ToInt32(Console.ReadLine());
            switch (OptionMenu)
            {
                case 1:
                    Console.WriteLine("CODIFICACION Y DECODIFICACION LZ77");
                    SearchAndDisplayCSVData(dpiInput, csvFilePath, bTree);
                    LZ77 encoder = new LZ77();
                    List<LZ77Token> encodedDpiTokens = encoder.Encode(dpiInput);
                    string decodedDpi = encoder.Decode(encodedDpiTokens);
                    Console.WriteLine($"Codificación LZ77 del DPI: {ConvertTokensToString(encodedDpiTokens)}");
                    Console.WriteLine($"Decodificación LZ77 del DPI: {decodedDpi}");
                    break;
                case 2:
                    string[] originalFiles = Directory.GetFiles(folderPath, $"REC-{dpiInput}-*.txt");
                    string[] encryptedFiles = Directory.GetFiles(folderPath, $"ENC-{dpiInput}-*.txt");

                    if (originalFiles.Length == 0)
                    {
                        Console.WriteLine("No se encontraron archivos originales para encriptar con el DPI proporcionado.");
                        continue; // Vuelve al inicio del bucle si no hay archivos
                    }

                    Console.WriteLine("¿Qué archivo deseas procesar?");
                    for (int i = 1; i <= originalFiles.Length; i++)
                    {
                        Console.WriteLine($"{i}. Archivo #{i}");
                    }
                    Console.WriteLine($"{originalFiles.Length + 1}. Todos los archivos");
                    int fileChoiceEncrypt = Convert.ToInt32(Console.ReadLine());

                    if (fileChoiceEncrypt <= originalFiles.Length)
                    {
                        EncryptFiles(new string[] { originalFiles[fileChoiceEncrypt - 1] }, dpiInput, outputFolderPath); // Procesa el archivo seleccionado
                    }
                    else
                    {
                        EncryptFiles(originalFiles, dpiInput, outputFolderPath); // Procesa todos los archivos
                    }
                    // Asegurándonos de que los archivos encriptados se estén recopilando correctamente
                    encryptedFiles = Directory.GetFiles(outputFolderPath, $"ENC-{dpiInput}-*.txt");
                    if (encryptedFiles.Length == 0)
                    {
                        Console.WriteLine("No se encontraron archivos encriptados para desencriptar con el DPI proporcionado.");
                    }
                    else
                    {
                        DecryptFiles(encryptedFiles, dpiInput, outputFolderPath);  // Igualmente, asegúrate de que la ruta de salida sea correcta
                    }
                    break;
                case 3:
                    //FIRMA
                    try
                    {
                        //Obtener el texto de la carta.
                        string textoCarta = ObtenerTextoCarta(folderPath, dpiInput);
                        if (textoCarta.StartsWith("Error") || textoCarta == "No hay cartas de recomendación para el DPI proporcionado.")
                        {
                            Console.WriteLine(textoCarta); // Mostrar el error o mensaje y terminar.
                            return;
                        }

                        // Generar las claves. El 'bitLength' depende de tus requisitos de seguridad.
                        var keys = SimpleRSA.GenerateKeys(bitLength);

                        // Calcular el hash SHA256 del contenido de la carta.
                        string HashValue = CalculateSHA256Hash(textoCarta);

                        // Obtener la firma digital.
                        string digitalSignature = CreateDigitalSignature(HashValue, keys.privateKey, keys.privateMod);

                        // Guardar la conversación y la firma digital en un archivo.
                        SaveConversationAndSignature(textoCarta, digitalSignature, signPath);

                        // AHORA SE CIFRA TODO EL CONTENIDO DEL ARCHIVO.

                        // Leer el contenido que acabas de guardar (conversación y firma digital).
                        string contenidoParaCifrar = File.ReadAllText(signPath);

                        // Encriptar el contenido completo usando tu método de encriptación.
                        string contenidoCifrado = DoubleColumnarTranspositionEncrypt(contenidoParaCifrar);

                        // Guardar el contenido cifrado de vuelta en el archivo o en un nuevo archivo, según prefieras.
                        // Si deseas sobrescribir el archivo existente, puedes usar 'signPath' como está.
                        // Si deseas crear un nuevo archivo para el contenido cifrado, especifica una nueva ruta.
                        File.WriteAllText(signPath, contenidoCifrado);  // Sobrescribe el archivo original.

                        Console.WriteLine("La conversación y la firma digital han sido guardadas y cifradas.");
                    }
                    catch (Exception ex)
                    {
                        // Manejo básico de excepciones para cualquier error inesperado durante el proceso.
                        Console.WriteLine($"Se produjo un error inesperado: {ex.Message}");
                    }
                    break;
                case 4:
                    // Llamada al método
                    DecryptAndSaveFile(signPath, SignatureValidationPath);
                    // Asumiendo que SignatureValidationPath está definida y accesible en este punto.
                    var results = ReadAndProcessFile(SignatureValidationPath);
                    //Console.WriteLine("Conversation Process: " + results.ConversationProcess);
                    //Console.WriteLine("Digital Signature Process: " + results.DigitalSignatureProcess);
                    string hashedConversation = CalculateSHA256Hash(results.ConversationProcess);
                    Console.WriteLine("Hashed Conversation Process: " + hashedConversation);
                    Console.WriteLine("Digital Signature Process: " + results.DigitalSignatureProcess);

                    /*/ VERIFICACIÓN
                    try
                    {
                        DecryptAndSaveFile(signPath, SignatureValidationPath);

                        // Leer y procesar el archivo.
                        var results = ReadAndProcessFile(SignatureValidationPath);

                        // Generar claves, si es necesario. Este paso podría ser innecesario si ya tienes la clave pública.
                        var keys = SimpleRSA.GenerateKeys(bitLength);

                        // Calcular el hash del contenido de la conversación.
                        string hashedConversation = CalculateSHA256Hash(results.ConversationProcess);

                        // Convertir la firma digital a BigInteger (esto asume que la firma está almacenada en formato hexadecimal en tu archivo).
                        BigInteger signature = BigInteger.Parse(results.DigitalSignatureProcess, System.Globalization.NumberStyles.AllowHexSpecifier);

                        // "Desencriptar" la firma digital usando la clave pública para obtener el hash original.
                        BigInteger retrievedHashBigInt = SimpleRSA.ApplyPublicKey(keys.publicKey, keys.publicMod, signature);

                        // Convertir el hash grande a una cadena en formato hexadecimal para comparación.
                        // Esto asume que tu función de hash devuelve una cadena hexadecimal y que el hash original se guardó en este formato.
                        string retrievedHashString = retrievedHashBigInt.ToString("X");

                        // Aquí, normalizamos ambos hashes para asegurar una comparación correcta (por ejemplo, ambos en mayúsculas).
                        if (hashedConversation.Equals(retrievedHashString, StringComparison.OrdinalIgnoreCase))
                        {
                            Console.WriteLine("¡La firma es válida!");
                        }
                        else
                        {
                            Console.WriteLine("La firma NO es válida.");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error durante la verificación: {ex.Message}");
                    }*/

                    break;
                case 5:
                    Console.Clear();
                    break;
                case 6:
                    Environment.Exit(0);
                    break;
                default:
                    Console.WriteLine("Seleccion invalida...");
                    break;
            }
        } while (OptionMenu != 4);
    }
    public static string ConvertTokensToString(List<LZ77Token> tokens)
    {
        return string.Join("", tokens.Select(t => $"<{t.Distance}, {t.Length}, {t.NextChar}>"));
    }
    private static void SearchAndDisplayCSVData(string dpi, string csvFilePath, BTree bTree)
    {
        dpi = dpi.Trim();
        JObject lastObject = null; // Último objeto encontrado para el DPI dado
        bool wasDeleted = false; // Bandera para indicar si el objeto fue eliminado

        using (StreamReader reader = new StreamReader(csvFilePath))
        {
            string line;
            while ((line = reader.ReadLine()) != null)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;

                // Divide la línea en ACCION;JSON
                string[] parts = line.Split(';', 2);
                if (parts.Length != 2) continue; // Ignorar líneas mal formadas

                string action = parts[0].Trim();
                string jsonPart = parts[1].Trim();

                if (line.Contains(dpi))
                {
                    try
                    {
                        JObject jsonObject = JObject.Parse(jsonPart);
                        if (jsonObject["dpi"]?.ToString().Trim() == dpi)
                        {
                            Record user = jsonObject.ToObject<Record>();

                            switch (action)
                            {
                                case "INSERT":
                                    bTree.Insert(user);
                                    lastObject = jsonObject;
                                    wasDeleted = false;
                                    break;
                                case "PATCH":
                                    bTree.Delete(user.DPI);
                                    bTree.Insert(user);
                                    lastObject = jsonObject;
                                    wasDeleted = false;
                                    break;
                                case "DELETE":
                                    bTree.Delete(user.DPI);
                                    wasDeleted = true;
                                    break;
                            }
                        }
                    }
                    catch (JsonException ex)
                    {
                        Console.WriteLine($"Error al analizar la línea '{line}': {ex.Message}");
                    }
                }
            }
        }
        // Lógica para imprimir el registro
        if (wasDeleted)
        {
            Console.WriteLine("El registro con el DPI dado ha sido eliminado.");
        }
        else if (lastObject != null)
        {
            Console.WriteLine($"Registro encontrado:\n{lastObject.ToString(Formatting.Indented)}");

            if (lastObject["companies"] != null)
            {
                string companies = String.Join(" ", lastObject["companies"].ToObject<List<string>>());
                if (!string.IsNullOrEmpty(companies))
                {
                    LZ77 encoder = new LZ77();
                    List<LZ77Token> encodedCompaniesTokens = encoder.Encode(companies);
                    string decodedCompanies = encoder.Decode(encodedCompaniesTokens);

                    Console.WriteLine($"Codificación LZ77 de las compañías: {ConvertTokensToString(encodedCompaniesTokens)}");
                    Console.WriteLine($"Decodificación LZ77 de las compañías: {decodedCompanies}");
                }
                else
                {
                    Console.WriteLine("El campo 'Companies' está vacío.");
                }
            }
            else
            {
                Console.WriteLine("El registro no contiene el campo 'Companies'.");
            }
        }
        else
        {
            Console.WriteLine("No se encontró el DPI en el archivo CSV.");
        }
    }

    //CIFRADO**************************************************************************************************************************************
    public static void EncryptAndSaveFile(string folderPath, string dpiInput)
    {
        string[] files = Directory.GetFiles(folderPath, $"REC-{dpiInput}-*.txt");

        if (files.Length == 0)
        {
            Console.WriteLine("No se encontraron archivos para el DPI proporcionado.");
            return;
        }

        Console.WriteLine("Cartas de recomendación disponibles:");
        for (int i = 0; i < files.Length; i++)
        {
            string fileNumber = Path.GetFileName(files[i]).Split('-')[2].Replace(".txt", "");
            Console.WriteLine($"{i + 1}. Carta #{fileNumber}");
        }

        Console.WriteLine($"{files.Length + 1}. Encriptar todas las cartas");
        Console.WriteLine("Ingrese el número de la opción que desea:");

        int choice;
        if (int.TryParse(Console.ReadLine(), out choice) && choice > 0 && choice <= files.Length + 1)
        {
            if (choice == files.Length + 1) // Opción para encriptar todas las cartas
            {
                foreach (string filePath in files)
                {
                    EncryptFile(filePath, dpiInput);
                }
            }
            else
            {
                string filePath = files[choice - 1];
                EncryptFile(filePath, dpiInput);
            }
        }
        else
        {
            Console.WriteLine("Selección inválida.");
        }
    }

    public static void EncryptFile(string filePath, string dpiInput)
    {
        string fileContent = File.ReadAllText(filePath);
        string encryptedContent = DoubleColumnarTranspositionEncrypt(fileContent);

        string newFileName = $"ENC-{dpiInput}-{Path.GetFileName(filePath).Split('-')[2]}";
        string newFilePath = Path.Combine(Path.GetDirectoryName(filePath), newFileName);

        File.WriteAllText(newFilePath, encryptedContent);
        Console.WriteLine($"Archivo {newFileName} encriptado y guardado.");
    }


    public static string DoubleColumnarTranspositionEncrypt(string plainText)
    {
        string firstEncryption = ColumnarTranspositionEncrypt(plainText, key1);
        return ColumnarTranspositionEncrypt(firstEncryption, key2);
    }
    public static string ColumnarTranspositionEncrypt(string plainText, string key)
    {
        int[] order = GetColumnOrder(key);

        // Agregar relleno al texto plano si es necesario.
        while (plainText.Length % key.Length != 0)
        {
            plainText += "X";
        }

        int numRows = plainText.Length / key.Length;
        char[,] matrix = new char[numRows, key.Length];

        int textPointer = 0;
        for (int row = 0; row < numRows; row++)
        {
            for (int col = 0; col < key.Length; col++)
            {
                matrix[row, col] = plainText[textPointer++];
            }
        }

        StringBuilder cipherText = new StringBuilder();
        for (int colIndex = 0; colIndex < key.Length; colIndex++)
        {
            int col = order[colIndex];
            for (int row = 0; row < numRows; row++)
            {
                cipherText.Append(matrix[row, col]);
            }
        }

        return cipherText.ToString();
    }
    public static void EncryptFiles(string[] originalFiles, string dpiInput, string outputFolderPath)
    {
        // Asegúrate de que el directorio de salida exista
        if (!Directory.Exists(outputFolderPath))
        {
            Directory.CreateDirectory(outputFolderPath);
        }

        foreach (string filePath in originalFiles)
        {
            string fileContent = File.ReadAllText(filePath);
            string encryptedContent = DoubleColumnarTranspositionEncrypt(fileContent);

            string newFileName = $"ENC-{dpiInput}-{Path.GetFileName(filePath).Split('-')[2]}";
            string newFilePath = Path.Combine(outputFolderPath, newFileName); // Aquí se cambia para usar outputFolderPath

            File.WriteAllText(newFilePath, encryptedContent);
            Console.WriteLine($"Archivo {newFileName} encriptado y guardado en {outputFolderPath}");
        }
    }


    //DESCIFRADO***********************************************************************************************************************************

    public static string DoubleColumnarTranspositionDecrypt(string cipherText)
    {
        // Asegúrate de que este orden esté correcto.
        string firstDecryption = ColumnarTranspositionDecrypt(cipherText, key2);
        return ColumnarTranspositionDecrypt(firstDecryption, key1);
    }

    public static string ColumnarTranspositionDecrypt(string cipherText, string key)
    {
        int[] order = GetColumnOrder(key);
        int numRows = (int)Math.Ceiling((double)cipherText.Length / key.Length);
        char[,] matrix = new char[numRows, key.Length];

        int textPointer = 0;
        for (int colIndex = 0; colIndex < key.Length; colIndex++)
        {
            int col = order[colIndex];
            for (int row = 0; row < numRows; row++)
            {
                if (textPointer < cipherText.Length) // Prevenir desbordamiento.
                {
                    matrix[row, col] = cipherText[textPointer++];
                }
            }
        }

        StringBuilder decryptedText = new StringBuilder();
        for (int row = 0; row < numRows; row++)
        {
            for (int col = 0; col < key.Length; col++)
            {
                decryptedText.Append(matrix[row, col]);
            }
        }

        // Eliminar las 'X' al final del texto descifrado. 
        // Es seguro asumir que cualquier 'X' al final del texto es relleno, ya que se añadió durante el cifrado.
        return decryptedText.ToString().TrimEnd('X');
    }
    public static void DecryptFiles(string[] encryptedFiles, string dpiInput, string outputFolderPath)
    {
        // Asegúrate de que el directorio de salida exista
        if (!Directory.Exists(outputFolderPath))
        {
            Directory.CreateDirectory(outputFolderPath);
        }

        foreach (string filePath in encryptedFiles)
        {
            string encryptedContent = File.ReadAllText(filePath);
            string decryptedContent = DoubleColumnarTranspositionDecrypt(encryptedContent);

            string newFileName = $"DEC-{dpiInput}-{Path.GetFileName(filePath).Split('-')[2]}";
            string newFilePath = Path.Combine(outputFolderPath, newFileName); // Aquí se cambia para usar outputFolderPath

            File.WriteAllText(newFilePath, decryptedContent);
            Console.WriteLine($"Archivo {newFileName} desencriptado y guardado en {outputFolderPath}");
        }
    }
    /******************************************************/

    public static void DecryptAndSaveFile(string signPath, string signatureValidationPath)
    {
        // Verifica si el archivo existe en la ruta proporcionada.
        if (!File.Exists(signPath))
        {
            Console.WriteLine($"El archivo no existe: {signPath}");
            return;
        }

        // Crear el directorio de salida si no existe.
        if (!Directory.Exists(signatureValidationPath))
        {
            Directory.CreateDirectory(signatureValidationPath);
        }

        try
        {
            // Leer el contenido cifrado del archivo.
            string encryptedText = File.ReadAllText(signPath);

            // Descifrar el contenido.
            string decryptedText = DoubleColumnarTranspositionDecrypt(encryptedText);

            // Eliminar la 'X' al final del texto descifrado si está presente.
            // Nota: esto asume que 'X' fue utilizada exclusivamente para el relleno durante el cifrado.
            if (decryptedText.EndsWith("X"))
            {
                decryptedText = decryptedText.TrimEnd('X');
            }

            // Crear un nombre de archivo basado en el archivo original.
            string newFileName = "decrypted_" + Path.GetFileName(signPath);

            // Componer la ruta completa donde se guardará el archivo descifrado.
            string fullOutputPath = Path.Combine(signatureValidationPath, newFileName);

            // Guardar el texto descifrado en el nuevo archivo.
            File.WriteAllText(fullOutputPath, decryptedText);

            Console.WriteLine($"Archivo descifrado guardado con éxito en {fullOutputPath}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"No se pudo procesar el archivo {signPath}: {ex.Message}");
            // Aquí puedes manejar errores específicos o generar logs según sea necesario.
        }
    }

    private static int[] GetColumnOrder(string key)
    {
        char[] originalKey = key.ToCharArray();
        char[] sortedKey = new char[key.Length];
        Array.Copy(originalKey, sortedKey, key.Length);
        Array.Sort(sortedKey);

        int[] order = new int[key.Length];
        for (int i = 0; i < key.Length; i++)
        {
            order[i] = Array.IndexOf(originalKey, sortedKey[i]);
            // Asegurarse de que no se selecciona el mismo índice dos veces.
            originalKey[order[i]] = '\0';
        }

        return order;
    }

    private static int[] GetInverseColumnOrder(string key)
    {
        int[] order = GetColumnOrder(key);
        int[] inverseOrder = new int[key.Length];

        for (int i = 0; i < order.Length; i++)
        {
            inverseOrder[order[i]] = i;
        }

        return inverseOrder;
    }

    /*************************************************************************************************************************/
    //METODO PARA OBTENER EL CONTENIDO DE LA CARTA DE RECOMENDACIÓN
    public static string ObtenerTextoCarta(string folderPath, string dpiInput)
    {
        string[] files;
        try
        {
            files = Directory.GetFiles(folderPath, $"CONV-{dpiInput}-*.txt");
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error al acceder al directorio: {ex.Message}");
            return "Error al buscar los archivos.";
        }

        if (files.Length == 0)
        {
            return "No hay cartas de recomendación para el DPI proporcionado.";
        }

        Console.WriteLine("Se han encontrado las siguientes conversaciones:");
        for (int i = 0; i < files.Length; i++)
        {
            string fileName = Path.GetFileName(files[i]);
            string numeroCarta = fileName.Split('-')[2].Split('.')[0];
            Console.WriteLine($"{i + 1}. CONVERSACION #{numeroCarta}");
        }

        Console.WriteLine("Ingrese el número de la conversacion que desea leer:");
        int choice;
        string input = Console.ReadLine();
        if (!int.TryParse(input, out choice) || choice < 1 || choice > files.Length)
        {
            return "Selección no válida.";
        }

        string filePath = files[choice - 1];
        string textoCarta;
        try
        {
            textoCarta = File.ReadAllText(filePath);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error al leer el archivo: {ex.Message}");
            return "Error al leer la carta.";
        }

        // Calcular el hash SHA256 del contenido de la carta.
        HashValue = CalculateSHA256Hash(textoCarta);

        return textoCarta;
    }
    private static string CalculateSHA256Hash(string text)
    {
        using (SHA256 sha256Hash = SHA256.Create())
        {
            // Convertir el texto de entrada en una matriz de bytes y calcular el hash.
            byte[] data = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(text));

            // Crear un nuevo StringBuilder para recoger los bytes y crear un string.
            StringBuilder builder = new StringBuilder();

            // Recorrer cada byte de los datos hash y formatear cada uno como una cadena hexadecimal.
            for (int i = 0; i < data.Length; i++)
            {
                builder.Append(data[i].ToString("x2"));
            }

            // Devolver la cadena hexadecimal.
            return builder.ToString();
        }
    }
    public static string CreateDigitalSignature(string hash, BigInteger privateKey, BigInteger privateMod)
    {
        // Convierte el hash de string a BigInteger (esto depende de cómo esté formateado tu hash).
        // Aquí estamos asumiendo que es una cadena hexadecimal.
        BigInteger hashInt = BigInteger.Parse(hash, System.Globalization.NumberStyles.AllowHexSpecifier);

        // Firmar el hash con tu clave privada. En RSA, esto se hace mediante encriptación con la clave privada.
        BigInteger digitalSignature = BigInteger.ModPow(hashInt, privateKey, privateMod);

        // Convertir la firma digital a una cadena hexadecimal y retornarla.
        return digitalSignature.ToString("X");
    }

    public static void SaveConversationAndSignature(string conversation, string signature, string filePath)
    {
        // Construir la cadena a guardar.
        StringBuilder dataToWrite = new StringBuilder();
        dataToWrite.AppendLine(conversation);
        dataToWrite.AppendLine("|"); // Delimitador.
        dataToWrite.AppendLine(signature);

        // Asegurar que el directorio exista, si no, crearlo.
        string directory = Path.GetDirectoryName(filePath);
        if (!Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        // Escribir el contenido en el archivo, creándolo si no existe.
        File.WriteAllText(filePath, dataToWrite.ToString());
    }

    //SE SEPARAN DEL DOCUMENTO
    public static (string ConversationProcess, string DigitalSignatureProcess) ReadAndProcessFile(string directoryPath)
    {
        // Comprobando si la ruta del directorio existe.
        if (!Directory.Exists(directoryPath))
        {
            throw new DirectoryNotFoundException("El directorio especificado no se encuentra.");
        }

        // Obteniendo todos los archivos en el directorio (suponiendo que sólo hay uno).
        string[] files = Directory.GetFiles(directoryPath);

        if (files.Length == 0)
        {
            throw new FileNotFoundException("No hay archivos en el directorio especificado.");
        }

        // Seleccionando el primer archivo. Puedes modificar esto para seleccionar un archivo específico si hay más de uno.
        string filePath = files[0];

        // Leyendo el contenido del archivo.
        string content = File.ReadAllText(filePath);

        if (string.IsNullOrWhiteSpace(content) || content.Length < 2)
        {
            throw new Exception("El archivo está vacío o el contenido es demasiado corto.");
        }

        // Eliminando el último carácter ('X') y dividiendo la cadena restante en partes.
        content = content.TrimEnd('X');
        string[] parts = content.Split('|');

        if (parts.Length != 2)
        {
            throw new FormatException("El contenido del archivo no tiene el formato correcto.");
        }

        string conversationProcess = parts[0].Trim();
        string digitalSignatureProcess = parts[1].Trim();

        // Devolviendo los resultados.
        return (conversationProcess, digitalSignatureProcess);
    }

}/********************************************TERMINA LA CLASS PROGRAM*****************************************************************************/

    
public class SimpleRSA
{
    private static readonly Random random = new();

    // Método simplificado para generar un número primo. No es eficiente para números muy grandes.
    private static BigInteger GeneratePrime(int bitLength)
    {
        while (true)
        {
            BigInteger candidate = GenerateRandomOddNumber(bitLength);
            if (IsProbablePrime(candidate))
            {
                return candidate;
            }
        }
    }

    // Genera un número impar aleatorio de la longitud de bit especificada.
    private static BigInteger GenerateRandomOddNumber(int bitLength)
    {
        byte[] bytes = new byte[bitLength / 8];
        random.NextBytes(bytes);
        bytes[bytes.Length - 1] &= (byte)0x7F; // Asegurar que sea un número positivo
        bytes[0] |= 1; // Asegurar que sea impar

        return new BigInteger(bytes);
    }

    // Test de primalidad simple (no es exhaustivo).
    private static bool IsProbablePrime(BigInteger source)
    {
        if (source == 2 || source == 3)
            return true;
        if (source < 2 || source % 2 == 0)
            return false;

        BigInteger d = source - 1;
        int s = 0;

        while (d % 2 == 0)
        {
            d /= 2;
            s += 1;
        }

        // Test de primalidad de Rabin-Miller
        for (int i = 0; i < 5; i++) // 5 tests
        {
            BigInteger a = 2 + (BigInteger)random.Next() % (source - 3);
            BigInteger x = BigInteger.ModPow(a, d, source);

            if (x == 1 || x == source - 1)
                continue;

            for (int r = 1; r < s; r++)
            {
                x = BigInteger.ModPow(x, 2, source);
                if (x == 1) return false;
                if (x == source - 1) break;
            }

            if (x != source - 1) return false;
        }
        return true;
    }

    // Generación de claves RSA simplificada.
    public static (BigInteger publicKey, BigInteger publicMod, BigInteger privateKey, BigInteger privateMod) GenerateKeys(int bitLength)
    {
        BigInteger p = GeneratePrime(bitLength / 2);
        BigInteger q = GeneratePrime(bitLength / 2);

        BigInteger n = p * q;
        BigInteger phi = (p - 1) * (q - 1);

        // Generar un 'e' aleatorio que sea coprimo con 'phi'.
        BigInteger e = GenerateCoPrime(phi);

        BigInteger d = ModInverse(e, phi);

        return (e, n, d, n); // Clave pública (e, n), Clave privada (d, n)
    }
    // Genera un número coprimo con el valor dado.
    private static BigInteger GenerateCoPrime(BigInteger withValue)
    {
        BigInteger result;
        do
        {
            // Esto genera un número aleatorio entre 2 y 'withValue'
            result = GenerateRandomInRange(2, withValue - 1);
        } while (BigInteger.GreatestCommonDivisor(result, withValue) != 1);

        return result;
    }
    // Generar un número aleatorio en un rango específico
    private static BigInteger GenerateRandomInRange(BigInteger min, BigInteger max)
    {
        byte[] bytes = max.ToByteArray();
        BigInteger result;

        do
        {
            random.NextBytes(bytes);
            result = new BigInteger(bytes);
        } while (result < min || result >= max || result.Sign < 0); // Verificación de rango y signo

        return result;
    }
    // Inverso modular para calcular 'd'.
    private static BigInteger ModInverse(BigInteger a, BigInteger m)
    {
        BigInteger m0 = m, y = 0, x = 1;

        if (m == 1)
            return 0;

        while (a > 1)
        {
            BigInteger q = a / m;
            BigInteger t = m;

            m = a % m;
            a = t;
            t = y;

            y = x - q * y;
            x = t;
        }

        if (x < 0)
            x += m0;

        return x;
    }
    public static BigInteger ApplyPublicKey(BigInteger publicKey, BigInteger publicMod, BigInteger signature)
    {
        // La "desencriptación" en RSA, cuando se usa la llave pública, es en realidad solo aplicar la exponenciación modular.
        return BigInteger.ModPow(signature, publicKey, publicMod);
    }

}


public class Record
{
    public string Name { get; set; }
    public string DPI { get; set; }
    public string DateBirth { get; set; }
    public string Address { get; set; }
    public List<string> Companies { get; set; }

    public Record()
    {
        Companies = new List<string>();
    }
}
public class BTreeNode
{
    public Record[] Records { get; set; }
    public int Degree { get; private set; }
    public BTreeNode[] Children { get; set; }
    public int RecordCount { get; set; }
    public bool IsLeaf { get; set; }

    public BTreeNode(int degree, bool isLeaf)
    {
        Degree = degree;
        IsLeaf = isLeaf;
        Records = new Record[2 * degree - 1];
        Children = new BTreeNode[2 * degree];
        RecordCount = 0;
    }
}
public class BTree
{
    private BTreeNode root;
    private int degree;

    public BTree(int degree)
    {
        root = null;
        this.degree = degree;
    }

    // Método para buscar un registro basado en el nombre
    public Record SearchByDpi(string encodedDpi)
    {
        return SearchByDpi(root, encodedDpi);
    }
    private Record SearchByDpi(BTreeNode node, string encodedDpi)
    {
        int idx = 0;

        // Encuentra el índice del primer registro mayor o igual que encodedDpi
        while (idx < node.RecordCount && encodedDpi.CompareTo(node.Records[idx].DPI) > 0)
            idx++;

        // Si el DPI es igual al registro en el índice idx, hemos encontrado el registro
        if (idx < node.RecordCount && node.Records[idx].DPI == encodedDpi)
            return node.Records[idx];

        // Si este nodo es un nodo hoja, entonces el DPI no está presente en el árbol
        if (node.IsLeaf)
            return null;

        // De lo contrario, busca el DPI en el subárbol correspondiente
        return SearchByDpi(node.Children[idx], encodedDpi);
    }

    // Método para insertar un nuevo registro
    public void Insert(Record user)
    {
        // Si el árbol está vacío
        if (root == null)
        {
            root = new BTreeNode(degree, true);
            root.Records[0] = user;
            root.RecordCount = 1;
        }
        else
        {
            // Si el nodo raíz está lleno, el árbol crece en altura
            if (root.RecordCount == 2 * degree - 1)
            {
                BTreeNode newNode = new BTreeNode(degree, false);
                newNode.Children[0] = root;
                SplitChild(newNode, 0, root);

                // Decide cuál de los dos hijos va a tener el nuevo registro.
                int i = 0;
                if (newNode.Records[0].DPI.CompareTo(user.DPI) < 0)  // Comparar DPI
                    i++;
                InsertNonFull(newNode.Children[i], user);

                root = newNode;
            }
            else
            {
                InsertNonFull(root, user);
            }
        }
    }

    // Método para eliminar un registro
    public void Delete(string dpi)
    {
        if (root == null)
        {
            Console.WriteLine("The tree is empty");
            return;
        }

        // Call the recursive delete function for root
        DeleteRecursive(root, dpi);

        // If the root node has 0 keys, make its first child the new root if it exists, otherwise set root as null.
        if (root.RecordCount == 0)
        {
            BTreeNode tempNode = root;

            if (root.IsLeaf)
                root = null;
            else
                root = root.Children[0];

            // Free the old root
            // In C#, garbage collector will take care of freeing, so we don't explicitly free the node.
        }

        return;
    }

    private void InsertNonFull(BTreeNode node, Record record)
    {
        int i = node.RecordCount - 1;

        // If this is a leaf node
        if (node.IsLeaf)
        {
            // Find the location of the new key in the records array and move other records to make space
            while (i >= 0 && record.DPI.CompareTo(node.Records[i].DPI) < 0)
            {
                node.Records[i + 1] = node.Records[i];
                i--;
            }

            // Insert the new record at the found location
            node.Records[i + 1] = record;
            node.RecordCount += 1;
        }
        else
        {
            // If this node is not a leaf node

            // Find the child which is going to have the new key
            while (i >= 0 && record.DPI.CompareTo(node.Records[i].DPI) < 0)
                i--;

            i++;
            BTreeNode child = node.Children[i];

            // If the child is full, then split it
            if (child.RecordCount == 2 * degree - 1)
            {
                SplitChild(node, i, child);

                // After the split, the middle record of child will move up to node, which will cause child to have degree-1 records.
                // Determine which of the two children will now receive the record (either the original child or its right sibling resulting from the split)
                if (record.DPI.CompareTo(node.Records[i].DPI) > 0)
                    i++;
            }

            InsertNonFull(node.Children[i], record);
        }
    }
    private void SplitChild(BTreeNode parentNode, int i, BTreeNode nodeToSplit)
    {
        BTreeNode newNode = new BTreeNode(nodeToSplit.Degree, nodeToSplit.IsLeaf);
        newNode.RecordCount = degree - 1;

        // Copy the last (degree-1) records of nodeToSplit to newNode
        for (int j = 0; j < degree - 1; j++)
            newNode.Records[j] = nodeToSplit.Records[j + degree];

        // If nodeToSplit is not a leaf, copy the last degree children of nodeToSplit to newNode
        if (!nodeToSplit.IsLeaf)
        {
            for (int j = 0; j < degree; j++)
                newNode.Children[j] = nodeToSplit.Children[j + degree];
        }

        // Reduce the number of records in nodeToSplit
        nodeToSplit.RecordCount = degree - 1;

        // Create space for a new child in the parentNode
        for (int j = parentNode.RecordCount; j >= i + 1; j--)
            parentNode.Children[j + 1] = parentNode.Children[j];

        // Link the newNode as child of parentNode
        parentNode.Children[i + 1] = newNode;

        // Move the middle record of nodeToSplit up to parentNode
        for (int j = parentNode.RecordCount - 1; j >= i; j--)
            parentNode.Records[j + 1] = parentNode.Records[j];

        parentNode.Records[i] = nodeToSplit.Records[degree - 1];

        // Increment count of records in parentNode
        parentNode.RecordCount += 1;
    }
    private void DeleteRecursive(BTreeNode node, string dpi)
    {
        int idx = 0;

        // Find the index of the record with the given name or the first record that is greater
        while (idx < node.RecordCount && dpi.CompareTo(node.Records[idx].DPI) > 0)
            idx++;

        // If the record to be deleted is found in the node
        if (idx < node.RecordCount && dpi == node.Records[idx].DPI)
        {
            if (node.IsLeaf)
            {
                // Simply remove the record from the leaf node
                RemoveFromLeaf(node, idx);
            }
            else
            {
                // Handle the more complex case of removing a record from a non-leaf node
                RemoveFromNonLeaf(node, idx);
            }
        }
        else
        {
            if (node.IsLeaf)
            {
                return;
            }

            // The flag indicates whether the record to be removed is present in the sub-tree rooted at node.Children[idx]
            bool flag = (idx == node.RecordCount);

            // If the child where the record is supposed to exist has less than degree records, fill that child
            if (node.Children[idx].RecordCount < degree)
                Fill(node, idx);

            // Recurse to the proper child after potential modifications
            if (flag && idx > node.RecordCount)
                DeleteRecursive(node.Children[idx - 1], dpi);
            else
                DeleteRecursive(node.Children[idx], dpi);
        }
    }
    private void RemoveFromLeaf(BTreeNode node, int idx)
    {
        for (int i = idx + 1; i < node.RecordCount; ++i)
            node.Records[i - 1] = node.Records[i];

        node.RecordCount--;
    }
    private void Fill(BTreeNode node, int idx)
    {
        if (idx != 0 && node.Children[idx - 1].RecordCount >= degree)
            BorrowFromPrev(node, idx);
        else if (idx != node.RecordCount && node.Children[idx + 1].RecordCount >= degree)
            BorrowFromNext(node, idx);
        else
        {
            if (idx != node.RecordCount)
                Merge(node, idx);
            else
                Merge(node, idx - 1);
        }
    }
    private void BorrowFromPrev(BTreeNode node, int idx)
    {
        BTreeNode child = node.Children[idx];
        BTreeNode sibling = node.Children[idx - 1];

        // Move all records of child one step ahead
        for (int i = child.RecordCount - 1; i >= 0; --i)
            child.Records[i + 1] = child.Records[i];

        // If child is not a leaf, move all child pointers one step ahead
        if (!child.IsLeaf)
        {
            for (int i = child.RecordCount; i >= 0; --i)
                child.Children[i + 1] = child.Children[i];
        }

        // Setting child's first record equal to node's idx-th record
        child.Records[0] = node.Records[idx - 1];

        // Moving the last child of the sibling as the first child of child
        if (!node.IsLeaf)
            child.Children[0] = sibling.Children[sibling.RecordCount];

        // Moving the last record from the sibling to the parent
        node.Records[idx - 1] = sibling.Records[sibling.RecordCount - 1];

        child.RecordCount += 1;
        sibling.RecordCount -= 1;

        return;
    }
    private void BorrowFromNext(BTreeNode node, int idx)
    {
        BTreeNode child = node.Children[idx];
        BTreeNode sibling = node.Children[idx + 1];

        // Setting the last record of child equal to idx-th record from node
        child.Records[child.RecordCount] = node.Records[idx];

        // Moving the first child of the sibling as the last child of child
        if (!child.IsLeaf)
            child.Children[child.RecordCount + 1] = sibling.Children[0];

        // Moving the first record from the sibling to idx-th position in node
        node.Records[idx] = sibling.Records[0];

        // Moving all records of sibling one step behind
        for (int i = 1; i < sibling.RecordCount; ++i)
            sibling.Records[i - 1] = sibling.Records[i];

        // Moving the child pointers of the sibling one step behind
        if (!sibling.IsLeaf)
        {
            for (int i = 1; i <= sibling.RecordCount; ++i)
                sibling.Children[i - 1] = sibling.Children[i];
        }

        child.RecordCount += 1;
        sibling.RecordCount -= 1;

        return;
    }
    private void Merge(BTreeNode node, int idx)
    {
        BTreeNode child = node.Children[idx];
        BTreeNode sibling = node.Children[idx + 1];

        child.Records[degree - 1] = node.Records[idx];

        for (int i = 0; i < sibling.RecordCount; ++i)
            child.Records[i + degree] = sibling.Records[i];

        if (!child.IsLeaf)
        {
            for (int i = 0; i <= sibling.RecordCount; ++i)
                child.Children[i + degree] = sibling.Children[i];
        }

        for (int i = idx + 1; i < node.RecordCount; ++i)
            node.Records[i - 1] = node.Records[i];

        for (int i = idx + 2; i <= node.RecordCount; ++i)
            node.Children[i - 1] = node.Children[i];

        child.RecordCount += sibling.RecordCount + 1;
        node.RecordCount--;

        // Liberar el nodo hermano
        // En C#, el recolector de basura se encargará de liberar, así que no liberamos explícitamente el nodo.
    }
    private void RemoveFromNonLeaf(BTreeNode node, int idx)
    {
        Record key = node.Records[idx];

        // Caso 1
        if (node.Children[idx].RecordCount >= degree)
        {
            Record pred = GetPredecessor(node, idx);
            node.Records[idx] = pred;
            DeleteRecursive(node.Children[idx], pred.Name);
        }
        // Caso 2
        else if (node.Children[idx + 1].RecordCount >= degree)
        {
            Record succ = GetSuccessor(node, idx);
            node.Records[idx] = succ;
            DeleteRecursive(node.Children[idx + 1], succ.Name);
        }
        // Caso 3
        else
        {
            Merge(node, idx);
            DeleteRecursive(node.Children[idx], key.Name);
        }
    }
    private Record GetPredecessor(BTreeNode node, int idx)
    {
        // Mueve al nodo más a la derecha hasta llegar a un nodo hoja
        BTreeNode cur = node.Children[idx];
        while (!cur.IsLeaf)
            cur = cur.Children[cur.RecordCount];

        // Devuelve el último registro del nodo hoja
        return cur.Records[cur.RecordCount - 1];
    }
    private Record GetSuccessor(BTreeNode node, int idx)
    {
        // Mueve al nodo más a la izquierda hasta llegar a un nodo hoja
        BTreeNode cur = node.Children[idx + 1];
        while (!cur.IsLeaf)
            cur = cur.Children[0];

        // Devuelve el primer registro del nodo hoja
        return cur.Records[0];
    }
}


// LZ77Token.cs
public record LZ77Token(int Distance, int Length, char NextChar)
{
    public override string ToString()
    {
        return $"<{Distance}, {Length}, {NextChar}>";
    }
}

public class LZ77
{
    public int WindowSize { get; }
    public int LookaheadBufferSize { get; }

    public LZ77(int windowSize = 4096, int lookaheadBufferSize = 32)
    {
        WindowSize = windowSize;
        LookaheadBufferSize = lookaheadBufferSize;
    }

    public List<LZ77Token> Encode(string input)
    {
        List<LZ77Token> output = new List<LZ77Token>();
        int i = 0;

        while (i < input.Length)
        {
            int maxMatchDistance = 0;
            int maxMatchLength = 0;
            char nextChar = '\0';

            for (int j = Math.Max(i - WindowSize, 0); j < i; j++)
            {
                int matchLength = 0;

                while ((i + matchLength) < input.Length &&
                       input[j + matchLength] == input[i + matchLength] &&
                       matchLength < LookaheadBufferSize)
                {
                    matchLength++;
                }

                if (matchLength > maxMatchLength)
                {
                    maxMatchDistance = i - j;
                    maxMatchLength = matchLength;
                }
            }

            if (i + maxMatchLength < input.Length)
            {
                nextChar = input[i + maxMatchLength];
            }

            // Agregar un nuevo LZ77Token en lugar de Tuple
            output.Add(new LZ77Token(maxMatchDistance, maxMatchLength, nextChar));
            i += maxMatchLength + 1;
        }

        return output;
    }

    public string Decode(List<LZ77Token> encodedData)
    {
        StringBuilder output = new StringBuilder();

        foreach (var token in encodedData)
        {
            int distance = token.Distance;
            int length = token.Length;

            for (int i = 0; i < length; i++)
            {
                output.Append(output[output.Length - distance]);
            }

            output.Append(token.NextChar);
        } 
        return output.ToString();
    }
}